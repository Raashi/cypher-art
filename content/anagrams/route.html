<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Маршрутное шифрование</title>
</head>
<body>
<p>Открытый текст разбивается на блоки длины <i>k*l</i> (<i>k</i>, <i>l</i> in <i>N</i>). Блок вписывается построчно в прямоугольную таблицу, состоящую из <i>k</i> строк и <i>l</i> столбцов. Соответствующий блок криптограммы получается выписыванием букв из этой таблицы в порядке их следования вдоль некоторого маршрута, который и является ключом.</p>
<p>Перед шифрованием необходимо сделать длину открытого текста кратной длине блока <i>k*l</i>. Для этого по необходимости в конец открытого текста добавляется нужное число букв. Обычно в качестве дополнительных букв выбирают самые частые буквы алфавита открытого текста. Неумелый выбор дополнительных знаков частично поможет криптоаналитику противника.</p>
<label for="route-select-rows">Число строк:</label>
<select id="route-select-rows">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
</select>
<label for="route-select-columns">Число столбцов:</label>
<select id="route-select-columns">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
</select>

<br>

<table max_elem="0" id="route-table">
    <!-- <tr><td>-</td></tr> -->
</table>

<label for="route-text">Открытый текст:</label>
<input id="route-text">
<button id="route-button-encrypt">Зашифровать</button>
<br>
<label for="route-encrypted">Расшифрованный текст:</label>
<textarea id="route-encrypted"></textarea>

<br>
<br>

<label for="route-cryptogram">Зашифрованный текст:</label>
<input id="route-cryptogram">
<button id="route-button-decrypt">Расшифровать</button>
<br>
<label for="route-decrypted">Криптограмма/расшифрованный текст:</label>
<textarea id="route-decrypted"></textarea>

<script type="text/javascript">
    const getCellByNumber = function (number /* int */) {
        const table = document.getElementById("route-table");
        const numberStr = number.toString();
        for (let i = 0; i < table.rows.length; i++)
            for (let j = 0; j < table.rows[0].cells.length; j++)
                if (table.rows[i].cells[j].innerHTML === numberStr)
                    return table.rows[i].cells[j];
        //TODO: return undefined or exception
        throw Error(`Не могу получить ячейку со значением ${number}`);
    };

    const unmarkCell = function (table, cell) {
        if (cell.innerHTML === "-")
            return;
        const number = parseInt(cell.innerHTML);
        const maxElem = parseInt(table.getAttribute("max_elem"));
        for (let i = maxElem; i > number; i--)
            getCellByNumber(i).innerHTML = "-";
        cell.innerHTML = "-";
        table.setAttribute("max_elem", (number - 1).toString());
    };

    const onclickCell = function (cell, table) {
        const text = cell.innerHTML;
        if (text === "-") {
            const maxElem = parseInt(table.getAttribute("max_elem"));
            cell.innerHTML = (maxElem + 1).toString();
            table.setAttribute("max_elem", cell.innerHTML);
        }
        else
            unmarkCell(table, cell);
    };

    const createCell = function (i, j, row, table) {
        const cell = document.createElement('td');
        cell.setAttribute("i", i.toString());
        cell.setAttribute("j", j.toString());
        cell.innerHTML = "-";
        cell.onclick = () => { onclickCell(cell, table) };
        row.appendChild(cell);
    };

    const deleteLastCell = function (i_row, table) {
        const row = table.rows[i_row];
        unmarkCell(table, row.lastChild);
        row.removeChild(row.lastChild);
    };

    const onRowsChange = function () {
        const table = document.getElementById("route-table");
        const rowsCountOld = table.rows.length;
        const rowsCount = parseInt(this.value);

        if (rowsCountOld === rowsCount)
            return;

        const colsCount = table.rows[0].cells.length;

        if (rowsCountOld < rowsCount)
            for (let i_row = rowsCountOld; i_row < rowsCount; i_row++) {
                const newRow = document.createElement('tr');
                for (let i = 0; i < colsCount; i++)
                    createCell(i_row, i, newRow, table);
                table.appendChild(newRow);
            }
        else
            for (let i_row = rowsCountOld - 1; i_row >= rowsCount; i_row--) {
                for (let i_col = colsCount - 1; i_col >= 0; i_col--)
                    deleteLastCell(i_row, table);
                table.removeChild(table.lastChild);
            }
    };
    const rowsInput = document.getElementById("route-select-rows");
    rowsInput.onchange = onRowsChange;

    const onColumnsChange = function () {
        const table = document.getElementById("route-table");
        const colsCountOld = table.rows[0].cells.length;
        const colsCount = parseInt(this.value);

        if (colsCountOld === colsCount)
            return;

        const rowsCount = table.rows.length;

        if (colsCountOld < colsCount)
            for (let i_col = colsCountOld; i_col < colsCount; i_col++) {
                for (let i_row = 0; i_row < rowsCount; i_row++)
                    createCell(i_row, i_col, table.rows[i_row], table);
            }
        else
            for (let i_col = colsCountOld; i_col > colsCount; i_col--)
                for (let i_row = 0; i_row < rowsCount; i_row++)
                    deleteLastCell(i_row, table);
    };

    const columnsInput = document.getElementById("route-select-columns");
    columnsInput.onchange = onColumnsChange;

    // rowsInput.onchange(null);
    const table = document.getElementById("route-table");
    const firstRow = document.createElement("tr");
    table.appendChild(firstRow);
    createCell(0, 0, firstRow, table);

    const getKey = function () {
        const table = document.getElementById("route-table");
        const rowsCount = table.rows.length;
        const colsCount = table.rows[0].childElementCount;
        if (parseInt(table.getAttribute("max_elem")) < rowsCount * colsCount) {
            //TODO: give user an error message - key not completed
            alert("Ключ не заполнен");
            return null;
        }
        const key = [];
        for (let i_row = 0; i_row < rowsCount; i_row++)
            for (let i_col = 0; i_col < colsCount; i_col++) {
                const cellText = table.rows[i_row].cells[i_col].innerHTML;
                key.push(parseInt(cellText));
            }
        return key;
    };

    const encryptBlock = function (block, key) {
        let result = "";
        for (let i = 0; i < key.length; i++)
            // 1-numeration to 0-numeration
            result += block.charAt(key[i] - 1);
        return result;
    };

    const encrypt = function () {
        const text = document.getElementById("route-text").value;
        const key = getKey();
        if (key === null)
            return;
        if (text.length % key.length > 0) {
            //TODO: give user an error message - text.length % key.length =/= 0
            alert("Тект невозможно разбить на блоки по длине ключа");
            return;
        }
        let cryptogram = "";
        const blocksCount = text.length / key.length;
        for (let iBlock = 0; iBlock < blocksCount; iBlock++) {
            const block = text.substring(iBlock * key.length, (iBlock + 1) * key.length);
            cryptogram += encryptBlock(block, key);
        }
        return cryptogram;
    };

    const decryptBlock = function (block, key) {
        let result = new Array(block.length);
        for (let i = 0; i < key.length; i++) {
            result[key[i] - 1] = block.charAt(i);
        }
        return result.join("");
    };

    const decrypt = function () {
        const cryptogram = document.getElementById("route-cryptogram").value;
        const key = getKey();
        if (key === null)
            return;
        if (cryptogram.length % key.length > 0) {
            //TODO: give user an error message - text.length % key.length =/= 0
            alert("Криптограмму невозможно разбить на блоки по длине ключа");
            return;
        }
        let decrypted = "";
        const blocksCount = cryptogram.length / key.length;
        for (let iBlock = 0; iBlock < blocksCount; iBlock++) {
            const block = cryptogram.substring(iBlock * key.length, (iBlock + 1) * key.length);
            decrypted += decryptBlock(block, key);
        }
        return decrypted;
    };

    const encryptButton = document.getElementById("route-button-encrypt");
    encryptButton.onclick = () => {
        const encrypted = encrypt();
        if (encrypted === undefined)
            return;
        document.getElementById("route-encrypted").innerHTML = encrypted;
    };

    const decryptButton = document.getElementById("route-button-decrypt");
    decryptButton.onclick = () => {
        const decrypted = decrypt();
        if (decrypted === undefined)
            return;
        document.getElementById("route-decrypted").innerHTML = decrypted;
    }
</script>
</body>
</html>