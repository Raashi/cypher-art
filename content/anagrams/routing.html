<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Routing encryption</title>
</head>
<body>
<p>Открытый текст разбивается на блоки длины <i>k*l</i> (<i>k</i>, <i>l</i> in <i>N</i>). Блок вписывается построчно в прямоугольную таблицу, состоящую из <i>k</i> строк и <i>l</i> столбцов. Соответствующий блок криптограммы получается выписыванием букв из этой таблицы в порядке их следования вдоль некоторого маршрута, который и является ключом.</p>
<p>Перед шифрованием необходимо сделать длину открытого текста кратной длине блока <i>k*l</i>. Для этого по необходимости в конец открытого текста добавляется нужное число букв. Обычно в качестве дополнительных букв выбирают самые частые буквы алфавита открытого текста. Неумелый выбор дополнительных знаков частично поможет криптоаналитику противника.</p>
<p>Число строк:</p><select id="routing-select-rows">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
</select>
<p>Число столбцов:</p><select id="routing-select-columns">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
</select>

<br>

<table max_elem="0" id="routing-table">
    <tr><td>-</td></tr>
</table>
<p>Открытый текст или криптограмма:</p><input id="routing-text">
<button id="routing-button-encrypt">Зашифровать</button>
<button id="routing-button-decrypt">Расшифровать</button>
<p>Криптограмма/расшифрованный текст:</p><input id="decrypted">
<script type="text/javascript">
    const getCellByNumber = function (number /* int */) {
        const table = document.getElementById("routing-table");
        const numberStr = number.toString();
        for (let i = 0; i < table.rows.length; i++)
            for (let j = 0; j < table.rows[0].cells.length; j++)
                if (table.rows[i].cells[j].innerHTML === numberStr)
                    return table.rows[i].cells[j];
        //TODO: return undefined or exception
        throw Error(`Не могу получить ячейку со значением ${number}`);
    };

    const unmarkCell = function (table, cell) {
        if (cell.innerHTML === "-")
            return;
        const number = parseInt(cell.innerHTML);
        const maxElem = parseInt(table.getAttribute("max_elem"));
        for (let i = maxElem; i > number; i--)
            getCellByNumber(i).innerHTML = "-";
        cell.innerHTML = "-";
        table.setAttribute("max_elem", (number - 1).toString());
    };

    const onclickCell = function (cell, table) {
        const text = cell.innerHTML;
        if (text === "-") {
            const maxElem = parseInt(table.getAttribute("max_elem"));
            cell.innerHTML = (maxElem + 1).toString();
            table.setAttribute("max_elem", cell.innerHTML);
        }
        else
            unmarkCell(table, cell);
    };

    const createCell = function (i, j, row, table) {
        const cell = document.createElement('td');
        cell.setAttribute("i", i.toString());
        cell.setAttribute("j", j.toString());
        cell.innerHTML = "-";
        cell.onclick = () => { onclickCell(cell, table) };
        row.appendChild(cell);
    };

    const deleteLastCell = function (i_row, table) {
        const row = table.rows[i_row];
        unmarkCell(table, row.lastChild);
        row.removeChild(row.lastChild);
    };

    const onRowsChange = function () {
        const table = document.getElementById("routing-table");
        const rowsCountOld = table.rows.length;
        const rowsCount = parseInt(this.value);

        if (rowsCountOld === rowsCount)
            return;

        const colsCount = table.rows[0].cells.length;

        if (rowsCountOld < rowsCount)
            for (let i_row = rowsCountOld; i_row < rowsCount; i_row++) {
                const newRow = document.createElement('tr');
                for (let i = 0; i < colsCount; i++)
                    createCell(i_row, i, newRow, table);
                table.appendChild(newRow);
            }
        else
            for (let i_row = rowsCountOld - 1; i_row >= rowsCount; i_row--) {
                for (let i_col = colsCount - 1; i_col >= 0; i_col--)
                    deleteLastCell(i_row, table);
                table.removeChild(table.lastChild);
            }
    };
    const rowsInput = document.getElementById("routing-select-rows");
    rowsInput.onchange = onRowsChange;

    const onColumnsChange = function () {
        const table = document.getElementById("routing-table");
        const colsCountOld = table.rows[0].cells.length;
        const colsCount = parseInt(this.value);

        if (colsCountOld === colsCount)
            return;

        const rowsCount = table.rows.length;

        if (colsCountOld < colsCount)
            for (let i_col = colsCountOld; i_col < colsCount; i_col++) {
                for (let i_row = 0; i_row < rowsCount; i_row++)
                    createCell(i_row, i_col, table.rows[i_row], table);
            }
        else
            for (let i_col = colsCountOld; i_col > colsCount; i_col--)
                for (let i_row = 0; i_row < rowsCount; i_row++)
                    deleteLastCell(i_row, table);
    };

    const columnsInput = document.getElementById("routing-select-columns");
    columnsInput.onchange = onColumnsChange;

    rowsInput.onchange(null);
</script>
</body>
</html>